<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600553 (zh-CN, DDL); Windows/6.3.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="667"/>
<h1>Redis的Linux环境安装</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/3/25 11:05</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/3/25 13:25</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div> <b>Redis下载和安装</b></div></li></ul><div><span>    </span><span>    </span> <a href="https://redis.io/download">https://redis.io/download</a></div></div></span>
</div>
<hr>
<a name="671"/>
<h1>Redis配置、命令和基本概念</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/3/25 13:25</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/3 22:28</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><div><div><div><div><ul><li><div><span style="font-weight: bold;">daemonize</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 是否是守护进程(no|yes)</div><div><br/></div><ul><li><div><span style="font-weight: bold;">port</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 对外端口号</div><div><br/></div><ul><li><div><span style="font-weight: bold;">logfile</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> Redis系统日志</div><div><br/></div><ul><li><div><span style="font-weight: bold;">dir</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> Redis工作目录，保存日志文件以及其他持久化文件的目录</div><div><br/></div><ul><li><div><span style="font-weight: bold;">Server 启动</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">     </span>   最简启动 : redis-server</div><div>            参数启动 : redis-server --port 6379 </div><div>            配置启动 : redis-server config/redis-6381.conf</div><div>            配置启动设置:</div><div>            cd /opt/redis</div><div>            mkdir config</div><div>            cp redis.conf config/</div><div>            mv redis.conf redis-6381.conf</div><div>            daemonize yes</div><div>            port 6381</div><div>            dir &quot;/var/redis/data&quot;</div><div>            logfile &quot;6381.log&quot;</div><div><br/></div><ul><li><div><span style="font-weight: bold;">Client启动</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;"> </span>   redis-cli -h 127.0.0.1 -p 6381</div><div>            redis-cli -h 192.168.153.128 -p 7000</div><ul><li><div> <span style="font-weight: bold;">查看Redis</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span> ps -ef|grep redis</div><div><br/></div><ul><li><div><span style="font-weight: bold;">通用命令</span></div></li></ul><div>            keys ：返回当前数据库所有的key,不要在生产环境使用，O(N)的遍历太重了 O(N)</div><div>            scan ： scane 0 match he* count 5  O(1)</div><div>            dbsize ： 返回当前数据库key的总数, 生产随便使用，redis内部维护了一个计数器 O(1)</div><div>            exists key ： 返回当前key是否存在，存在返回1,不存在返回0 O(1)</div><div>            del key [key..] : 可以删除一个或者多个key O(1)</div><div>            expire key seconds : 给key设置过期时间 O(1)</div></div><div>            ttl ：查看当前key剩余过期时间  -1表示key存在,但是没有过期时间 -2代表key已经被删除 O(1)</div><div>            persist : 去掉key的过期时间 O(1)</div><div>            type key: O(1)</div><div><br/></div><ul><li><div> <span style="font-weight: bold;">string</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> get | set | del | incr | decr | incrby | decrby | setnx | setxx | mget | mset | getset | append | strlen | increbyfloat | getrange | setrange</div><div>            setnx : key不存在才进行设置</div><div>            setxx : key存在才设置</div><div>            getset : set新的值返回老的值</div><div>            strlen : 计算长度</div><div>            getrange : 获得key指定索引的value值 getrang hello 3 4</div><div><br/></div><ul><li><div><span style="font-weight: bold;">hash</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;"> </span>   hget | hset | hdel | hgetall | hexists | hlen | hmget | hmset | hincrby | hincrbyfloat | hvals | hkeys | hsetnx</div><div><br/></div><ul><li><div><span style="font-weight: bold;">list</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> rpush | linsert | lpop | rpop | lrem | ltrim | lrange | index | llen | lset | blpop | brpop</div><div>            linsert listKey before|after value newvalue</div><div>            lrem key count value : count表示要删除几个值和value相等的项, 如果是负数表示从右开始删除</div><div>            ltrim key start end :按照索引修剪列表</div><div><span style="font-weight: bold;">         </span>   index key index</div><div>            lset key index</div><div>            lpop key timeout : timeout 如果是0那么永远阻塞等待直到有一条数据</div><div>            </div><ul><li><div><span style="font-weight: bold;">set</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> sinter | sdiff | sunion | sadd | srem | scard | sismember | srandmember | smembers | scan | spop</div><div>            scard : 计算元素</div></div><div>            sinter key1 key2 [store key3]</div><div><br/></div><ul><li><div><span style="font-weight: bold;">zset</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> zadd | zrem | zscore | zincrby | zacard | zrank | zrang | zrangebyscore | zcount | zremrangebyrank | zremrangebyscore | zrevrank | | zrevrange</div><div>            zadd key score element</div><div>            zscore key element</div><div>            zincrby key increScore element</div><div>            zrank key element : 获得排名</div><div>            zrange key start end</div><div>            zrangebyscore key minScore maxScore</div><div>            zravrank ： 由低到高的排名</div><div><br/></div><ul><li><div><span style="font-weight: bold;">慢查询</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    redis将符合条件的慢查询放在一个固定大小的队列中，先入先出</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> slowlog-max-len : default 128</div><div>            slowlog-log-slower-than ： 阈值 default 10ms </div><div>            config set slowlog-max-len 1000</div><div>            config set slowlog-log-slower-than 1000</div></div><div>            slowlog get[n] | slowlog len | slowlog reset</div><div>            slowlog get[n] ： 获得慢查询队列</div><div><br/></div><ul><li><div><span style="font-weight: bold;">Pipeline</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;"> </span>   将多个命令在客户端放在一个命令管道中再传给redis以达到节约网络开销的目的</div><div>            1次请求pipleline命令(多个command) = 1次网络开销+n次命令开销</div><div>            注意pipleline是非原子的，在redis端会对命令进行拆分，不是顺序执行</div><div>            pipleline不允许在redis集群使用</div><div><br/></div></div><ul><li><div><span style="font-weight: bold;">发布订阅</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> publish channel message</div><div>            subscribe /unsbuscribe channel</div><div>            psubscribe [partten]</div><div>            pubsub channels</div><div>            pubsub numsub [channel...] : 给出给定频道的订阅者数量</div><div><br/></div><ul><li><div><span style="font-weight: bold;">bitmap 位图</span></div></li></ul><div>            getbit key offset</div><div>            setbit key offset value</div><div>            bitcount key [start end] : 获得位图偏移量值位1的个数</div><div>            bitop op deskKey key [key...] : 操作多个bitmap的and|or|not|xor 并将结果保存在deskKey中</div><div>            bitpos key targetBit [start] [end] : 计算位图指定范围</div></div><div><br/></div><ul><li><div> <span style="font-weight: bold;">hyperloglog</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 用极小的空间完成独立数量的统计，本质还是string, 内存消耗很小，有错误率0.81%,无法取得单条数据</div><div>            pfadd key element [element...]</div><div>            pfcount key </div><div>            pfmerge destKey sourceKey [sourceKey...] : 合并多个key</div><div><br/></div><ul><li><div><span style="font-weight: bold;">GEO</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 存储经纬度，计算两地距离，范围计算等</div><div>            geokey 其实就是zset</div><div>            geoadd key longitude latitude member [longitude latitude member...]</div><div>            geopos key member [member...]</div><div>            geodist key member1 member2 [unit] : 计算两地距离 unit: m | km | mi | ft</div><div>            getradiusbymember key longitude latitude ； 指定范围内的member</div><div>            zrem key member</div><div><br/></div><div><br/></div><ul><li><div><span style="font-weight: bold;">主从复制</span></div></li></ul><div>            <span style="font-weight: bold;">master slave 结构，高可用，但是</span><span style="font-weight: bold;">没有实现故障的自动转移</span></div><div>            slaveof ： redis-6382&gt; slaveof 127.0.0.1 6381  (异步命令)</div><div>            slaveof no one ： 取消复制</div><div>            配置文件 slaveof ip port</div><div>            info replication : 查看当前server状态</div><div>            全量复制 ： master写入到slave,并且在写入过程中如果master发生变化也将变化写入</div><div>            部分复制 ： 如果在同步过程中发生网络抖动，通过偏移量的对比进行同步</div><div>            slave宕机： 让有读数据需求的client连接到别的slave</div><div>            master宕机： 选一个slave进行slaveof on one操作， 其他slave进行slaveof新的master的操作，对新选master的读操作的client连接到别的slave上</div><div>            读写分离可能用到的问题：数据复制延迟，读到过期数据，从节点故障</div><div>            主从配置尽量一致</div><div>            尽量规避全量复制，低峰处理</div><div>            复制缓冲区不足 rel_backlog_set 值调大一点(默认 1M)</div><div>            最好还是用哨兵或者集群进行处理</div><div>            复制风暴：大量slave挂掉 | 主挂掉，从复制 | </div><div>                            可以更换复制拓扑，比如主-3个从变成 主-1个从-2个从</div><div>                            如果是多个master，尽量分散在不同机器</div><div><br/></div><div><br/></div></div><div><span>    </span><span>    </span><span>    </span><br/></div><div><br/></div></span>
</div>
<hr>
<a name="677"/>
<h1>业务场景使用和最佳实践</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/3/26 15:49</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/3 22:10</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><div><div><ul><li><div><span style="font-weight: bold;">记录用户访问</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> incr userid:page </div><div>            hincrby key  field 1</div></div><div><br/></div><ul><li><div><span style="font-weight: bold;">分布式主键</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> incr</div><div><br/></div><ul><li><div><span style="font-weight: bold;">分布式锁</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span>set lock locked EX 5 nx</div><div><br/></div><ul><li><div><span style="font-weight: bold;">使用mget或者mset来节约网络开销</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> n次get = n次网络开销+n次命令开销 </div><div>            1次mget = 1次网络开销 +n次命令开销</div><div><br/></div><ul><li><div><span style="font-weight: bold;"> 对于大数据量的list使用ltrim逐端裁剪进行list的删除</span></div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">redis实现集合</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> lpush + lpop = stack</div><div>            lpush + rpop = queue</div><div>            lpush + brpop = message queue</div><div><br/></div><ul><li><div><span style="font-weight: bold;">抽奖系统</span></div></li></ul><div>            spop</div><div>            </div><ul><li><div><span style="font-weight: bold;">赞，踩</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> sadd</div><div><br/></div><ul><li><div><span style="font-weight: bold;">给用户添加标签/给标签添加用户</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> sadd</div><div> </div></div><ul><li><div><span style="font-weight: bold;">共同关注</span></div></li></ul><div>            sinter</div></div><div><br/></div><ul><li><div><span style="font-weight: bold;">排行榜</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 有序集合<span style="font-weight: bold;"> </span>zadd</div><div>            score可以使用 timestamp, salesCount , followCount 等等</div><div><br/></div><ul><li><div><span style="font-weight: bold;"> </span><span style="font-weight: bold;">slowlog-log-slower-than </span><span style="font-weight: bold;">不要设置过大，默认10ms，通常1ms</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> qps一般都是过万的，如果某一次执行超过1ms，那么就应该记录一下这种有影响的操作</div><div><br/></div><ul><li><div><span style="font-weight: bold;">slowlog-max-len不要设置过小，默认128，通常1000</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 因为我们想看到一些历史的信息</div><div><br/></div><ul><li><div><span style="font-weight: bold;">定期做慢查询的持久化</span></div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">使用bitmap做独立用户统计</span></div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">使用GEO数据来实现餐馆发现，微信摇一摇等</span></div></li></ul><div><b><br/></b></div><div><b><br/></b></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="681"/>
<h1>Jedis最佳实践</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/3/27 0:53</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/3/27 1:11</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">Jedis Pool配置</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><b>   </b> 平均处理时间是0.1ms， QPS = 5000， maxTotal = 0.001s * 5000 = 50<br/></div><div><span>    </span><span>    </span><span>    maxIdle = maxTotal</span><br/></div><div><span><span>    </span><span>    </span><span>    预热minIdle</span><br/></span></div><div><span><span>    </span><span>    </span><span>    try catch jedis操作并释放资源给连接池(jedis.close())</span><br/></span></div><div><span><br/></span></div><div><img src="Evernote_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="Evernote_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="Evernote_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="691"/>
<h1>Redis sentinel</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/3/27 21:43</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/6 6:25</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">主从复制问题</span></div></li></ul><div>           手动故障转移</div><div>           写能力和存储能力受限(一个master)</div><div><br/></div><ul><li><div><span style="font-weight: bold;">安装</span></div></li></ul><ol><ol><li><div>准备主从节点</div></li></ol></ol><div>                       cd /opt/redis-5.0.4/config</div><div>                       vim redis-7000.conf</div><div>                       port 7000</div><div>                       daemonize yes</div><div>                       pidfile /var/data/redis-7000.pid</div><div>                       logfile &quot;7000.log&quot;</div><div>                       dir &quot;/var/redis/data&quot;</div><div>                        bind 192.168.153.128</div><div>                       相同操作创建7001和7002的配置文件如下(实际场景要部署在不同的机器上)</div><div>                       port 7001</div><div>                       daemonize yes</div><div>                       pidfile /var/data/redis-7001.pid</div><div>                       logfile &quot;7001.log&quot;</div><div>                       dir &quot;/var/redis/data&quot;</div><div>                        bind 192.168.153.128</div><div>                       slaveof bind 192.168.153.128 7000</div><div>                  2.  启动主从</div><div>                       redis-server redis-7000.conf</div><div>                       redis-server redis-7001.conf</div><div>                       redis-server redis-7002.conf</div><div>                 3.   准备哨兵</div><div>                       cd /opt/redis-5.0.4</div><div>                       vim sentinel.conf</div><div>                       cp sentinel.conf config/</div><div>                       cd config</div><div>                       cat sentinel.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; &gt; redis-sentinel-26379.conf</div><div>                       vim redis-sentinel-26379.conf 修改配置文件如下</div><div>                        port 26379</div><div>                       daemonize yes</div><div>                       pidfile /var/redis/data/redis-sentinel-26379.pid</div><div>                       logfile &quot;26379.log&quot;</div><div>                       dir /var/redis/data</div><div>                       sentinel monitor mymaster 192.168.153.128 7000 2</div><div>                       sentinel down-after-milliseconds mymaster 30000</div><div>                       sentinel parallel-syncs mymaster 1</div><div>                       sentinel failover-timeout mymaster 180000</div><div>                       sentinel deny-scripts-reconfig yes</div><div>                       创建另外两个哨兵</div><div>                       sed &quot;s/26379/26380/g&quot; redis-sentinel-26379.conf  &gt; redis-sentinel-26380.conf</div><div>                       sed &quot;s/26379/26381/g&quot; redis-sentinel-26379.conf  &gt; redis-sentinel-26381.conf</div><div>                   4. 启动哨兵</div><div>                       redis-sentinel redis-sentinel-26379.conf</div><div>                       redis-sentinel redis-sentinel-26380.conf</div><div>                       redis-sentinel redis-sentinel-26381.conf</div><div>            </div><ul><li><div><span style="font-weight: bold;">三个定时任务</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span>    每十秒每个sentinel对master和slave进行info操作 ： 发现节点，确定主从</div><div>            每两秒每个sentinel通过master节点的channel交换信息：交换对节点的看法</div><div>            每秒每个sentinel对其他sentinel和redis执行ping</div><div><br/></div><ul><li><div><span style="font-weight: bold;">主观下线和客观下线</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> sentinel monitor &lt;masterName&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</div><div>            sentinel monitor mymaster 192.168.153.128 7000 2</div><div>            sentinel down-after-milliseconds mymater 30000 如果超过30秒还没有收到master或者slave回复则将节点下线</div><div>            主观下线：由于网络等原因，redis本身并没有坏掉，所以sentinel是有偏见的</div><div>            客观下线： 所有sentinel节点对redis节点失败达成共识(超过quorum数量)</div><div>                             sentinel会互相询问是否对master进行下线 sentinel is-master-down-by-addr</div><div><br/></div><ul><li><div><span style="font-weight: bold;">领导者选举</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 只有一个sentinel节点完成故障转移</div><div>            sentinel is-master-down-by-addr 互相询问是否master下线，然后进行领导者选举</div><div><br/></div><ul><li><div><span style="font-weight: bold;">故障自动转移</span></div></li></ul><div>            slave中选出一个master：</div><div>                    可以对高配机器添加slave-priority属性，这样选举新master会优先选举</div><div>                    可以选择偏移量最大的slave节点</div><div>                    选择runId最小的节点(启动最早)</div><div>            对选中的master执行slaveof no one</div><div>            告知其他slave</div><div>            将原master标记为slave并监控，恢复后命令他去新的master复制数据</div><div><br/></div><ul><li><div><span style="font-weight: bold;">节点运维</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 机器下线：机器过保等</div><div>            机器性能不足：CUP、磁盘、网络、内存等</div><div>            节点自身故障：服务器不稳等</div><div>            主节点下线 ：sentinel failover &lt;mastername&gt;</div><div>            从节点下线：临时还是永久，是否做清理工作，考虑读写分离</div><div>            主节点上线：sentinel failover会自己替换</div><div>            从节点上线：直接slaveof即可</div><div>            sentinel节点：直接起或者关</div><div><br/></div><ul><li><div><span style="font-weight: bold;">高可用读写分离</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> sentinel实现了高可用和故障自动转移，但是要读写分离需要自己去写，不建议</div><div>            真正的读写分离还是要通过redis cluster的集群进行动态扩展，读写操作还是在主节点上实现</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="697"/>
<h1>Redis Cluster</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/3/28 21:24</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/3 21:44</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><div><ul><li><div><span style="font-weight: bold;">为什么要用redis集群</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 并发量(QPS) : redis号称每秒可执行10万条命令，但是业务场景需要100万/秒怎么办？</div><div>            数据量 : 机器内存16~256G，业务需要500G</div><div>            网络流量：网卡需求达到好几千兆</div><div>            解决方案：</div><div>                配置超大内存机器, 超强CPU的机器</div><div>                加机器，分区</div><div>            Redis Cluster实现了 复制+高可用+<span style="font-weight: bold;">分片, </span>可以在多个主节点上进行读写</div><div>            </div><ul><li><div><span style="font-weight: bold;">数据分区</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 顺序分区和哈希分区</div><div>            哈希分区：数据分散度高，键值分布业务无关，无法顺序访问，支持批量操作, 例如redis, memcache等</div><div>            顺序分区： 数据分散度易倾斜，键值业务相关，可顺序访问，不支持批量操作，例如bigtable，hbase</div><div>            哈希分区方式：节点取余分区，一致性哈希，虚拟槽分区</div><div>            节点取余分区：节点伸缩会产生数据迁移，迁移率80%，可以用翻倍扩容进行解决，迁移率50%</div><div>            一致性哈希：哈希+顺时针(优化取余)， 节点伸缩只影响相邻节点，还是无法实现负载均衡，因为有热节点</div><div>            虚拟槽分区：假设数据范围16383,5个槽，那么CRC16( key)%16383看是哪个范围，cluster找到对应数据范围所在的节点，首先客户端将请求发给redis cluster任意一个节点，节点判断当前key 是否在自己槽里，如果不在，由于每个节点由于记录了其他节点的槽信息，把请求发给相应的槽的节点。</div><div>                                可是实现动态扩容,加一个槽就是把某一些数据交给槽处理，但是数据不会迁移</div><div><br/></div></div><ul><li><div><span style="font-weight: bold;">Redis Cluster 架构</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 节点：多个主节点</div><div>            meet：多个主节点间相互通信</div><div>            指派槽：对节点指派槽，也就是对应的数据区间， 0~16383</div><div>            主从：每个主节点都有从节点，高可用，故障自动转移，不需要sentinel</div><div><br/></div></div><ul><li><div><span style="font-weight: bold;">原生安装</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> cluster-enabled yes</div><div>            cluster-node-timeout 15000</div><div>            cluster-config-file nodes-${port}.conf</div><div>            cluster-require-full-coverage no: 如果集群内有节点不工作，那么整个集群对外不提供服务,一般配置成no</div><div>            cluster meet ip port : 在集群的某一个节点的redis-cli中执行</div><div>            cluster addslots slot[slot...] 在各自的节点的redis-cli执行分配槽命令 cluster addslots {0...5461}</div><div>            cluster replicate nodeId : 设置主从 </div><div>            详细安装步骤：</div><div>            1. 准备节点 , 在单linux机器上进行操作，生产环境要放在不同的机器上</div><div>                redis-7003.conf如下</div><div>                port 7003</div><div>                daemonize yes</div><div>                pidfile /var/data/redis-7003.pid</div><div>                logfile &quot;7003.log&quot;</div><div>                dir &quot;/var/redis/data&quot;</div><div>                dbfilename &quot;dump-7003.rdb&quot;</div><div>                bind 192.168.153.128</div><div>                cluster-enabled yes</div><div>                cluster-config-file nodes-7003.conf</div><div>                cluster-require-full-coverage no</div><div>                sed &quot;s/7003/7004/g&quot; redis-7003.conf  &gt; redis-7004.conf</div><div>                sed &quot;s/7003/7005/g&quot; redis-7003.conf  &gt; redis-7005.conf</div><div>                sed &quot;s/7003/7006/g&quot; redis-7003.conf  &gt; redis-7006.conf</div><div>                sed &quot;s/7003/7007/g&quot; redis-7003.conf  &gt; redis-7007.conf</div><div>                sed &quot;s/7003/7008/g&quot; redis-7003.conf  &gt; redis-7008.conf</div><div>                可以用cluster node和cluster info在客户端查看节点的集群信息、</div><div>            2.  节点握手(meet)</div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7004</div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7005            </div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7006</div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7007   </div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7008   </div><div>                redis-cli -h 192.168.153.128 -p 7003|7005 cluster nodes|info： 检测节点是否握手</div><div>            3. 分配槽</div><div>                写一个脚本来分配槽</div><div>                cd /opt/redis-5.0.4 </div><div>                mkdir scripts</div><div>                cd scripts</div><div>                vim addslots.sh添加如下</div><div>                start=$1</div><div>                end=$2</div><div>                ip=$3</div><div>                port=$4</div><div>                for slot in `seq ${start} ${end}`</div><div>                do       </div><div>                    echo &quot;slot:${slot}&quot;</div><div>                     redis-cli -h ${ip} -p ${port} cluster addslots ${slot}</div><div>                done    </div><div>                执行分配槽的命令</div><div>                 sh addslots.sh 0 5461 192.168.153.128 7003</div><div>                 sh addslots.sh 5462 10922 192.168.153.128 7004</div><div>                 sh addslots.sh 10923 16383 192.168.153.128 7005</div><div>                查看结果</div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster slots</div><div>                4. 主从分配</div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster nodes</div><div>                根据打印出来的节点的node id绑定主从关系</div><div>                redis-cli -h 192.168.153.128 -p 7006 cluster replicate dd3a34f9fa0961a39c8c066a0b7fabd599aa91bb</div><div>                redis-cli -h 192.168.153.128 -p 7007 cluster replicate 454973ee92a3c17829963def84fedc66d4eb8721</div><div>                redis-cli -h 192.168.153.128 -p 7008 cluster replicate 8c5c1cb3d3f5434b1f8ee9132ad1f68a22beb7d0</div><div>                查看分配结果</div><div>                redis-cli -h 192.168.153.128 -p 7003 cluster info</div><div><br/></div><ul><li><div><span style="font-weight: bold;">Ruby安装</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> cd /opt</div><div>            wget <a href="https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz">https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz</a></div><div>            tar -xvf ruby-2.3.1.tar.gz</div><div>            cd ruby-2.3.1</div><div>            ./configure -prefix=/usr/local/ruby</div><div>            ./configure &amp;&amp; make &amp;&amp; make install</div><div>            </div><div>            wget <a href="http://rubygems.org/downloads/redis-3.3.0.gem">http://rubygems.org/downloads/redis-3.3.0.gem</a></div><div>            sudo gem install -l redis-3.3.0.gem</div><div>            sudo gem list</div><div><br/></div><div>            启动所有的server</div><div>            在redis5里面要通过redis-cli进行命令处理，而不是redis-trib.rb</div><div><br/></div><ul><li><div><span style="font-weight: bold;">其他</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 自动化部署</div><div><br/></div><ul><li><div><span style="font-weight: bold;">集群伸缩</span></div></li><ul><li><div><span style="font-weight: bold;">扩展集群</span></div></li></ul></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">     </span>启动两个新的redis server 7009,7010</div><div>                     sed &quot;s/7003/7009/g&quot; redis-7003.conf  &gt; redis-7009.conf</div><div>                     sed &quot;s/7003/7010/g&quot; redis-7003.conf  &gt; redis-7010.conf</div><div>                     redis-server redis-7009.conf</div><div>                     redis-server redis-7010.conf</div><div>                     redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7009</div><div>                     redis-cli -h 192.168.153.128 -p 7003 cluster meet 192.168.153.128 7010</div><div>                     redis-cli -h 192.168.153.128 -p 7010 cluster replicate 2f3b2556adc62709631341df1d6e10d346e4d4ff</div><ul><ul><li><div><span style="font-weight: bold;">迁移槽</span></div></li></ul></ul><div><span style="font-weight: bold;">                     </span>迁移槽和数据</div><div>                     cluster setslot {slot} importing {sourceNodeId} 让目标节点准备导入槽数据</div><div>                     cluster setslot {slot} migrating {targetNodeId} 让源节点准备导出槽数据</div><div>                     cluster getkeysinslot {slot} {count} 源节点循环执行，每次获取count个属于槽的键</div><div>                     migrate {targetIp} {targetPort} key 0 {timeout} 命令把key迁移</div><div>                     重复上两步把所有槽的数据迁移到目标节点</div><div>                     cluster setslot {slot} node {targetNodeId} 通知集群内其他节点槽已被重新分配</div><div>                     </div><ul><li><div><span style="font-weight: bold;">Move重定向</span></div></li></ul><div><span style="font-weight: bold;">            </span>redis-cli <span style="font-weight: bold;">-c</span> -h 192.168.153.128 -p 7003</div><div>            set hello world 会返回ok    </div><div>            set php best 会返回-&gt; Redirected to slot [9244] located at 192.168.153.128:7004 OK    </div><div>            因为在集群环境下会先算出key的hash，然后和16383取余计算出槽的位置，再重定向到集群中对应节点</div><div><br/></div><ul><li><div><span style="font-weight: bold;">ask重定向</span></div></li></ul><div><span style="font-weight: bold;">           </span> 客户端发起请求但是槽还在迁移中</div><div>            </div><ul><li><div><span style="font-weight: bold;">smart客户端</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 追求性能 redis cluster</div><div>            1.从集群选一个可运行节点，使用cluster slots初始化槽和节点的映射</div><div>            2.将cluster结果映射到本地，为每个节点创建jedispool</div><div>            3.直接连接到对应节点执行命令</div><div>            4.要兼顾move异常和ask异常，重新初始化slot和node的关系</div><div>            单例</div><div>            不用归还连接给连接池</div><div>            合理设置common pool</div><div><br/></div><ul><li><div><span style="font-weight: bold;">数据批量操作</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 由于redis cluster要求批量操作必须在同一个槽</div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 串行mget for循环getkey</div><div>            串行IO/并行IO 通过本地CRC16和16383取余操作的到对应槽，然后把key分组进行pipleline批量操作，可在多线程环境下做</div><div>            hash_tag 将hash用tag值包装 当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。</div><div><br/></div><ul><li><div><span style="font-weight: bold;">客观下线</span></div></li></ul><div>            半数以上的主节点认为某个节点连接失败</div><div><br/></div><ul><li><div><span style="font-weight: bold;">故障恢复</span></div></li></ul><div>            资格检查：从节点是否可用</div><div>            准备选举时间：找到偏移量最大的从节点</div><div>            选举投票：其他主节点进行投票</div><div>            替换主节点</div><div>                    1.slaveof no one</div><div>                    2.将故障节点的槽分配给自己</div><div>                    3.通知其他主节点自己已经替换了故障节点</div><div><br/></div><ul><li><div><span style="font-weight: bold;">带宽消耗</span></div></li></ul><div>            节点规模过大，如超过1000，节点间通信带宽消耗过大</div><div>            避免大集群，大业务可以拆分成多个集群</div><div>            cluster-node-timeout</div><div>            尽量分配到多机器上，保证高可用和带宽</div><div><br/></div><ul><li><div><span style="font-weight: bold;">pub/sub</span></div></li></ul><div>            集群中每个节点进行广播和订阅，影响带宽</div><div><br/></div><ul><li><div><span style="font-weight: bold;">集群倾斜</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 数据倾斜和请求倾斜(热点)</div><div>            数据倾斜</div><div>                槽和节点分布不均匀 redis-trib.rb info ip:port 查看节点、槽、键值分布  redis-trib.rb rebalance ip:port 进行均衡(谨慎使用)</div><div>                不同槽对应键值数量差别很大  可能存在hash_tag    cluster countkeysinslot {slot} 获取槽对应的键值个数</div><div>                包含bigkey 例如大字符串，几百万元素的hash，set等    redis-cli  --bigkeys(建议在从节点执行) 优化数据结构，打散等</div><div>                内存相关配置不一致    定期检查配置的一致性</div><div>            请求倾斜</div><div>                热点key 避免使用bigkey，热键不要使用hash_tag，当一致性要求不高，可以使用本地缓存+mq</div><div><br/></div><ul><li><div><span style="font-weight: bold;">读写分离</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 只读连接：redis集群中，从节点不支持任何读写请求，会把请求重定向到主节点</div><div>                             readyonly，连接级别命令，实现读操作</div><div>            读写分离更加复杂，需要考虑复制延迟，读取过期数据，从节点故障等问题，建议通过动态扩容进行性能优化。如果实在不行，将业务拆分成小集群再进行处理。总之不建议使用读写分离。</div><div><br/></div><ul><li><div><span style="font-weight: bold;">数据迁移</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> redis-trib.rb import 将单节点数据迁移到集群</div><div>            不支持在线迁移</div><div>            不支持断点续传</div><div>            单线程迁移，影响速度</div><div>            在线迁移工具:</div><div>            唯品会 redis-migrate-tool</div><div>            豌豆荚 redis-port</div><div><br/></div><ul><li><div><b>集群VS单机</b></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><b>   </b> 集群对批量操作支持有限，例如mget，mset必须在同一个槽<br/></div><div><span>    </span><span>    </span><span>    复制只支持一层，不支持树形复制</span><br/></div><div><span><span>    </span><span>    </span><span>    很多时候单机已经能满足需求了</span><br/></span></div><div><span><span>    </span><span>    </span><span>    集群无法跨节点使用：mget、keys等操作</span><br/></span></div><div><span><span>    </span><span>    </span><span>    本身客户端维护更复杂</span><br/></span></div><div><span><span>    </span><span>    </span><span>    很多场景redis sentinel已经足够好了！</span><br/></span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="699"/>
<h1>缓存的设计和优化</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/3 22:19</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/7 7:14</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">缓存的收益</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 加速读写</div><div>            降低后端负载</div><div><br/></div><ul><li><div><span style="font-weight: bold;">缓存的成本</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 缓存和数据层有时间窗口不一致，和更新策略有关</div><div>            代码维护成本，多了一层缓存逻辑</div><div>            运维成本</div><div><br/></div><ul><li><div><span style="font-weight: bold;">使用场景</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 对高消耗的sql，比如某一个时间点的排行榜</div><div>            加速相应时间 </div><div>            大量写操作合并为批量写，比如redis累加然后再批量写入DB</div><div>            </div><ul><li><div><span style="font-weight: bold;">缓存更新策略</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">  </span> <span style="font-weight: bold;"> </span><span style="font-weight: bold;">   </span> <span style="font-size: 10pt;">1.LRU/LFU/FIFO算法剔除：例如maxmemory-policy</span></div><div><span style="font-size: 10pt;">              </span><span style="background-color:rgb(255, 255, 255);"><a href="https://blog.csdn.net/hfismyangel/article/details/79518452" style="outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">https://blog.csdn.net/hfismyangel/article/details/79518452</a></span></div><div style="outline: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;"><span style="outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-variant-caps: normal; font-variant-ligatures: normal;">          </span></font>    noeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error</div><div style="text-align: start;">              allkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据</div><div style="text-align: start;">              volatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据</div><div style="text-align: start;">              allkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据</div><div style="text-align: start;">              volatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据</div><div style="text-align: start;">              volatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据</div><div>            2. 超时剔除， 设置过期时间</div><div>            3. 主动更新 ： 开发控制生命周期</div><div>            低一致性的数据：最大内存和淘汰策略</div><div>            高一致性的数据：超时剔除+主动更新，最大内存和淘汰策略兜底</div><div><br/></div><ul><li><div><span style="font-weight: bold;">缓存颗粒度问题</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 缓存全部属性或是部分属性</div><div>            通用性：全属性更好</div><div>            占用空间：部分属性好</div><div>            代码维护：全属性更好</div><div><br/></div><ul><li><div><span style="font-weight: bold;">缓存穿透</span></div></li></ul><div>            大量请求不命中缓存，访问持久层，持久层也没有数据，</div><div>                由于业务代码自身原因</div><div>                恶意攻击、爬虫</div><div>            如何发现</div><div>                业务的响应时间</div><div>                业务本身的问题</div><div>            相关指标：总调用数、缓存层命中数、存储层命中数</div><div>            解决方法：</div><div>                缓存空对象，设置一个过期时间</div><div>                    可能需要更多的键</div><div>                    缓存层和储存层短期的不一致</div><div>               </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                String cacheV = cache.get(key);</div><div>                if(cacheV==null){</div><div>                    String storeV = store.get(key);</div><div>                    cache.set(key,storeV);</div><div>                    if(storeV==null){</div><div>                        cache.expire(key,100);</div><div>                    }</div><div>                }else{</div><div>                    return cacheV;</div><div>                }</div><div><br/></div><div><br/></div></div><div><br/></div><ul><li><div><span style="font-weight: bold;">缓存雪崩</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 当cache服务宕机，大量请求发送至DB，造成级联故障</div><div>            优化方案</div><div>                缓存高可用，集群和sentinel等</div><div>                客户端组件为后端限流</div><div>                提前演练</div><div>                资源隔离，各自的线程池进行管理</div><div><br/></div><ul><li><div><span style="font-weight: bold;">无底洞问题</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 大量节点的集群，加节点之后性能反而下降</div><div>            节点太多，一次mget回到n个节点获得数据，O(N)</div><div>            优化IO:</div><div>                优化命令本身，例如慢查询、hgetall bigkey</div><div>                减少网络通信次数</div><div>                降低接入成本，例如客户端长连接/连接池，NIO等</div><div>            </div><ul><li><div><span style="font-weight: bold;">热点key的重建优化</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 减少缓存重建次数</div><div>            数据尽可能一致</div><div>            减少潜在风险</div><div>            解决思路</div><div>                互斥锁：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                String cacheV = cache.get(key);</div><div>                if(cacheV==null){</div><div>                    String mutexKey = &quot;mutexkey&quot;+key;</div><div>                    if(cache.set(mutexKey,&quot;1&quot;,&quot;ex100&quot;,&quot;nx&quot;)){</div><div>                        String storeV = store.get(key);</div><div>                        cache.set(key,storeV);    </div><div>                        cache.delete(mutexKey);</div><div>                        if(storeV==null){</div><div>                            cache.expire(key,100);    </div><div>                        }</div><div>                    }else{</div><div>                        Thread.sleep(50);</div><div>                        get(Key);</div><div>                    }</div><div>                   </div><div>                }else{</div><div>                    return cacheV;</div><div>                }</div><div><br/></div><div><br/></div></div><div>                 永远不过期</div><div> </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                String cacheV = cache.get(key);</div><div>                if(cacheV==null){</div><div>                    String mutexKey = &quot;mutexkey&quot;+key;</div><div>                    if(cache.set(mutexKey,&quot;1&quot;,&quot;ex100&quot;,&quot;nx&quot;)){</div><div>                        String storeV = store.get(key);</div><div>                        cache.set(key,storeV);    </div><div>                        cache.delete(mutexKey);</div><div>                        if(storeV==null){</div><div>                            cache.expire(key,100);    </div><div>                        }</div><div>                    }else{</div><div>                        Thread.sleep(50);</div><div>                        get(Key);</div><div>                    }</div><div>                   </div><div>                }else{</div><div>                    return cacheV;</div><div>                }</div><div><br/></div><div><br/></div></div><div><br/></div><ul><li><div><span style="font-weight: bold;">热点key的寻找</span></div></li></ul><div>            抓取机器的包</div><div>            服务端monitor统计，并发量非常高的情况下，monitor对应的客户端的缓冲区会暴增，把当前redis内存撑爆</div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div>
<hr>
<a name="703"/>
<h1>布隆过滤器</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/5 8:54</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/5 21:23</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">有50亿个电话号码，现在有10万个电话号码，要快速准确判断这些电话号码是否存在</span></div></li></ul><div><span style="font-weight: bold;">   </span> <span style="font-weight: bold;">   </span><span style="font-weight: bold;">   </span> 通过数据库查询实现，无法实现快速</div><div>           数据放在集合中，50亿*8字节约40GB，内存浪费或者不够</div><div>           hyperloglog 无法实现准确性</div><div>           类似问题如垃圾邮件的过滤，文字处理检测 , 网络爬虫重复url检测</div><div><br/></div><ul><li><div><span style="font-weight: bold;">布隆过滤器基本原理</span></div></li></ul><div><span style="font-weight: bold;">   </span> <span style="font-weight: bold;">   </span><span style="font-weight: bold;">   </span> m个很长的二进制向量，n个预备数据，k个hash函数</div><div>           遍历n，对每个值取hash值，得到的hash值会跟向量的点做到映射，并在向量对应位置标1</div><div><br/></div><ul><li><div><span style="font-weight: bold;">误差率</span></div></li></ul><div><span style="font-weight: bold;">   </span> <span style="font-weight: bold;">   </span><span style="font-weight: bold;">   </span> 肯定存在误差：恰好都命中了</div><div>           m/n，k的个数，比例越大，误差率越低，因为数组很大</div><div>           命中公式： 1- (1-1/m)nk次方</div><div><br/></div><ul><li><div><span style="font-weight: bold;">本地布隆过滤器</span></div></li></ul><div>           guava</div><div>               容量受限</div><div>              多个应用必须在本地建立布隆过滤器，同步会有问题</div><div>          </div><ul><li><div><span style="font-weight: bold;">Redis-bloomFilter</span></div></li></ul><div>           实现：</div><div>               定义布隆过滤器构造函数 m，n，k，误差概率</div><div>               定义布隆过滤器操作函数 add和contain</div><div>               封装Redis位图操作</div><div>           比本地慢，输在网络，可以和应用部署在同一个机房</div><div><span>    </span><span>    </span><span>   容量受限，需要用集群</span><br/></div></div></span>
</div>
<hr>
<a name="705"/>
<h1>Redis开发规范</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/5 21:50</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/6 8:54</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">键值设计</span></div></li></ul><div>            key</div><div>                可读性和可管理性：以业务名为前缀，冒号分割, 业务名:表名:id  ugc:vedio:1</div><div>                简洁性：在把key的语义表达清晰的前提下，尽量控制key的长度</div><div>                不要包含特殊字符：例如空格、换行、单双引号以及其他转义字符</div><div>                小于39的value值，会以embstr形式存储(超过39就是raw)，节省开销，如果redis部署在阿里云等收费服务器上，可以节约很多成本 object encoding key 查看key的类型，</div><div>            Value </div><div>                拒绝bigkey</div><div><span style="font-weight: bold;">                选择合适的数据结构</span></div><div>                过期设计</div><div><br/></div><ul><li><div> <span style="font-weight: bold;">拒绝bigkey</span></div></li></ul><div>            String类型超过10KB就是bigkey</div><div>            hash,list,set,zset元素个数不要超过5000</div><div>            反例：一个巨大的json对象或者一个有好几百万元素的list等</div><div>            big key 危害：网络阻塞，redis阻塞（慢查询），集群节点数据不均匀(节点数据数量差不多，但是占用内存相差很大)，频繁序列化(服务器CPU的消耗)</div><div>            big key的发现：线上异常或者redis-cli --bigkeys，scan debuge object，主动报警：网络流量监控，客户端监控</div><div>                应用方发现：</div><div>                    JedisconnectionException:socketTimeout:Read time out</div><div>                bigkeys：在本地执行，在slave节点执行</div><div>                scan：可以用len等找到长度大于某个值的keys</div><div><br/></div><ul><li><div><span style="font-weight: bold;">bigkey的删除</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> bigkey的删除可能造成阻塞</div><div>            bigkey的过期、rename等隐性删除也会造成阻塞</div><div>            由于慢查询只会记录客户端产生的行为，所以隐式的删除不会被记录，但是在从节点的日志文件中可以找到，因为在同步过程中，主节点伪装成了一个客户端</div><div>            Redis 4.0之后支持unlink(lazy delete) 后台起一个线程进行删除</div><div>            Redis 3.0先scan部分元素后删除，最后删bigkey</div><div>            Bigkey的预防：拆分，物理隔离、万兆网卡，使用bigkey的时候部分scan或者hmget这种获得部分元素</div><div><br/></div><ul><li><div><span style="font-weight: bold;">合适的数据结构</span></div></li></ul><div><span style="font-weight: bold;">           </span> 元素大于64小于512会使用zplist，ziplist在物理上是连续的，读写有指针位移，新增删除有内存重新分配，减少了数据碎片，提高了读写效率</div><div>            全string，全hash，分段hash</div><div><br/></div><ul><li><div><span style="font-weight: bold;">键值生命周期</span></div></li></ul><div>            周期数据要设置过期时间，否则造成垃圾数据堆积，管理混乱等</div><div>            object idle time 找到key -value的闲置时间</div><div>            过期时间不宜集中，会造成缓存穿透，雪崩问题</div><div><br/></div><ul><li><div><span style="font-weight: bold;">命令优化</span></div></li></ul><div>            对于大bigkey有遍历需求可以使用scan</div><div>            禁用命令keys、flushall等</div><div>            尽量不要使用数据库隔离(select)：客户端支持差，切换后混乱等</div><div>            redis事务功能弱，不建议使用，不支持回滚等</div><div>            不要过分使用lua，如果非要使用，不要使用集群</div><div>            不要长时间使用monitor，并发量非常高的情况下，monitor对应的客户端的缓冲区会暴增，把当前redis内存撑爆</div><div><br/></div><ul><li><div><span style="font-weight: bold;">java客户端优化</span></div></li></ul><div>            避免多个应用使用一个redis实例，会造成key混乱重复，或者一个业务的阻塞级联影响其他业务</div><div>            不相干的业务进行拆分，公共数据做服务化，服务化就是提供数据服务，而不是直接提供redis数据，比如提供http的api给其他项目组</div><div>            使用连接池，详见Jedis最佳实践</div><div><br/></div><ul><li><div><span style="font-weight: bold;">连接池参数优化</span></div></li></ul><div>            Maxtotal 最大连接数</div><div>            maxidle 最大空闲连接数</div><div>            minidle 最小空闲连接数</div><div>            blockWhenExhaused 资源用尽后是否等待，默认true，建议使用默认值</div><div>            maxWaitMills 资源用尽后等待时间，默认-1，不建议使用默认值，会造成大范围阻塞甚至服务停用</div><div>            testOnBorrow 从池子取资源后，是否进行ping操作，默认false，QPS大建议使用false，因为一次ping也是一次开销</div><div>            testOnReturn 当把资源归还给池子，是否进行ping操作，默认false，QPS大建议使用false</div><div>            jmxEnabled 是否开启jmx监控，默认true，建议开启，但是应用本身也要开启</div><div><span>    </span><span>    </span><span>    testWhileIdle 是否开启空闲连接检测，默认false，建议true，因为Redis服务端会对某些超时没有读写的连接进行断开操作，所以客户端这边的某些空闲连接可能已经和服务端断开了，所以我们要检测一下</span><br/></div><div><span><span>    </span><span>    </span><span>    timeBetweenEvictionRunMills 空闲检测周期(毫秒)，默认-1不检测，建议设置成5分钟，或者使用jedispoolconfig里面的配置</span><br/></span></div><div><span>    </span><span>    </span><span>    minEvictableTimeMills 空闲多少时间才认为是空闲资源，默认1000*60*30=30分钟，建议</span>jedispoolconfig里面的配置(1分钟)<br/></div><div><font face="Courier New">    </font><font face="Courier New">  </font>NumTestsPerEvictionRun 每次采集空闲样本数量，默认3，可以设置成-1</div><div><br/></div><ul><li><div><b>如何预估最大连接池</b></div></li></ul><div><span>    </span><span>    </span><span>    maxIdle和maxTotal接近</span><br/></div><div><span><span>    </span><span>    </span><span>    maxtotal：考虑业务希望达到并发量，客户端执行命令时间，node*maxtotal不能超过redis最大连接数，资源开销</span><br/></span></div><div><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  假设一个命令执行了1ms(borrow&amp;return jedis，网络开销，命令执行)，一个连接的qps大约是1000次，业务希望qps能够达到5W，理论上maxtotal就是50个，可以适当伸缩。</span></div><div><span><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>  要获得这个平均耗时比较困难，需要在客户端进行统计</span>  </span><br/></span></div><div><br/></div><div><br/></div><div>                </div></div><div><br/></div></span>
</div>
<hr>
<a name="707"/>
<h1>Redis内存优化</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/6 8:57</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/6 11:50</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><span style="font-weight: bold;">内存消耗</span></div></li></ul><div>            内存使用统计：info memory</div><div>            内存消耗划分</div><div>                    自身内存 800K左右</div><div>                    对象内存</div><div>                    缓冲内存 ：客户端缓冲区，复制缓冲区，AOF缓冲区</div><div>                    lua内存</div><div>            子进程内存消耗</div><div><br/></div><ul><li><div><span style="font-weight: bold;">客户端缓冲区</span></div></li></ul><div>            普通客户端缓冲区</div><div>            slave客户端</div><div>            pubsub客户端</div><div>            输入缓冲区：Redis允许的客户端输入缓冲区是1G，超过1G客户端连接直接被服务端干掉</div><div>            输出缓冲区：可以进行配置</div><div>                client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</div><div>                &lt;class&gt;: 客户端类型 normal，slave，pubsub</div><div>                &lt;hard limit&gt;: 如果客户端输出缓冲区大于该值 ，直接关闭客户端</div><div>                &lt;soft limit&gt; &lt;soft seconds&gt;：如果客户端使用的输出缓冲区超过soft limit并且持续了 soft sconds，关闭客户端</div><div>            普通客户端缓冲区</div><div>                 默认不会对普通客户端的缓冲区做限制 client-output-buffer-limit  normal 0 0 0</div><div>                 由于普通客户端缓冲区没有被阻塞，一定不要执行长命令或慢查询等</div><div>            slave客户端缓冲区 </div><div>                  默认  client-output-buffer-limit slave 256mb 64mb 60</div><div>                  主从延迟高，或者从节点过多，可能造成阻塞</div><div>                  主从网络，从节点不要超过2个</div><div>                  可以适当把hard limit调大，因为slave只有从master同步的操作，适当调大hard limit可以保证一直连接，而不是断开连接发生全量复制，这样做会牺牲一些内存</div><div>             pubsub缓冲区：</div><div>                  默认  client-output-buffer-limit slave 32mb 8mb 60</div><div>            client list命令查看缓冲区信息</div><div><br/></div><ul><li><div><span style="font-weight: bold;">复制缓冲区</span></div></li></ul><div>            默认1M，可以调大比如100M</div><div><br/></div><ul><li><div><span style="font-weight: bold;">AOF缓冲区</span></div></li></ul><div>            无限制</div><div><br/></div><ul><li><div><span style="font-weight: bold;">对象内存</span></div></li></ul><div>            key不要过长</div><div>            value 选择合适数据结构</div><div><br/></div><ul><li><div><span style="font-weight: bold;">内存碎片</span></div></li></ul><div>            必然存在，因为使用jemalloc进行内存分配</div><div>            优化方式:</div><div>                避免频繁更新操作</div><div>                安全重启，sentinel，集群等，可以通过主从切换进行内存重分的操作，进行碎片整理</div><div><br/></div><ul><li><div><span style="font-weight: bold;">子进行内存消耗</span></div></li></ul><div>            fork，bgsave等</div><div>            优化方式：</div><div>                观察写入量</div><div>                overcommit设置为1</div><div><br/></div><ul><li><div><span style="font-weight: bold;">内存设置上限</span></div></li></ul><div>            假设一台机器24GB，4个redis node每个4GB，操作系统4GB，留出4GB，一般预留30%空闲内存</div><div>            config set maxmemory 6GB</div><div>            config rewrite</div><div><br/></div><ul><li><div><span style="font-weight: bold;">内存回收策略</span></div></li></ul><div>            过期键删除：</div><div>                惰性删除：访问key-&gt;expire dict-&gt;del key</div><div>                定时删除：每秒运行10次，采样删除，随机采样，超过25%过期才会进行删除步骤</div><div>            内存溢出策略：<span style="font-size: 10pt;">maxmemory-policy</span></div><div style="outline: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-variant-caps: normal; font-variant-ligatures: normal;">          </span><span style="outline: 0px; overflow-wrap: break-word; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">    noeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error</span></div><div style="text-align: start;">              allkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据</div><div style="text-align: start;">              volatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据</div><div style="text-align: start;">              allkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据</div><div style="text-align: start;">              volatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据</div><div style="text-align: start;">              volatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据</div><div>    </div><ul><li><div><b>其他</b>            </div></li></ul><div><span>    </span><span>    </span><span>    </span>使用序列化或者压缩方法，如protocol buffer</div><div><span>    </span><span>    </span><span>    </span><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>            </div></div><div><br/></div></span>
</div>
<hr>
<a name="709"/>
<h1>Redis运维</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/7 6:20</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/7 7:08</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><ul><li><div><span style="font-weight: bold;">Overcommit_memory</span></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><b>   </b> 控制内存申请，建议设置成1，保证fork不会出错<br/></div><div>            0    如果有足够内存，申请通过，否则申请失败，并把错误返回给应用进程</div><div>            1    表示内核允许超量使用内存</div><div>            2    内核绝不超量使用内存，</div><div>            获取</div><div>                cat /proc/sys/vm/overcommit_memory</div><div>            设置</div><div>                echo &quot;vm.overcommit_memory=1&quot; &gt;&gt; /etc/sysctl.conf</div><div>                sysctl vm.overcommit_memory=1</div></div><div><br/></div><ul><li><div><b>swappniess</b></div></li></ul><div><span>    </span><span>    </span><span>    设置成0</span><br/></div><div><span><br/></span></div><ul><li><div><b>安全的Redis</b></div></li></ul><div><span>    </span><span>    </span><span>    1. 设置密码</span><br/></div><div><span><span>    </span><span>    </span><span>    </span><span>    requirepass、masterauth在主从都进行设置，因为可能主从切换</span><br/></span></div><div><span><span>    </span><span>    </span><span>    </span><span>    密码要足够复杂，防止暴力破解</span><br/></span></div><div><span><span>    </span><span>    </span><span>    </span><span>2.<span> <span>rename-command 为空或者随机字符，建议随机字符，并且只有管理员知道</span></span></span><br/></span></div><div><span>    </span><span>    </span><span>    </span><span>    在server的conf文件中加入</span>rename-command keys abc***432，这样在生产环境除了管理员其他人无法使用keys命令</div><div><span><span>    </span><span>    </span><span>    </span><span>    不支持动态config set</span><br/></span></div><div><span><span>    </span><span>    </span><span>    </span><span>    RDB或AOF如果包含rename-command之前的命令，将无法使用</span><br/></span></div><div><span>    </span><span>        </span>3. bind 限制网卡流量，并不是客户端ip</div><div><span>    </span><span>    </span><span>    </span><span>    </span>不支持动态config set<br/></div><div><span>    </span><span>    </span><span>    </span><span>    不要bind 127.0.0.1</span><br/></div><div><span><span>    </span><span>    </span><span>    </span><span>    如果存在外网网卡，尽量屏蔽掉</span><br/></span></div><div><span><span>    </span><span>    </span><span>    </span>4. 防火墙</span></div><div><span><span>    </span><span>    </span><span>    5. 定期备份</span><br/></span></div><div><span><span>    </span><span>    </span><span>    6. 不使用默认端口</span><br/></span></div><div><span><span>    </span><span>    </span><span>    7. 使用非root用户启动</span><br/></span></div></div></span>
</div>
<hr>
<a name="701"/>
<h1>Redis cacheCloud</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/4/4 0:37</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2019/4/4 8:11</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><ul><li><div><b>规模化运维的困扰</b></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><b>   </b> 发布构建繁琐，私搭乱盖<br/></div><div><span>    </span><span>    </span><span>    节点&amp;机器运维成本</span><br/></div><div><span><span>    </span><span>    </span><span>    监控报警比较初级</span><br/></span></div><div><span><br/></span></div><ul><li><div><b>cacheCloud</b></div></li></ul><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><b>   </b> 一键开启Redis(单点，哨兵，集群)<br/></div><div><span>    </span><span>    </span><span>    机器、应用、实例监控和报警</span><br/></div><div><span><span>    </span><span>    </span><span>    客户端：透明使用，性能上报</span><br/></span></div><div><span><span>    </span><span>    </span><span>     可视化运维：配置、扩容、Failover、机器上下线等 </span><br/></span></div><div><span><span>    </span><span>    </span><span>    已存在的redis直接接入和数据迁移</span><br/></span></div><div><span>    </span><span>    </span><span>    </span><a href="https://github.com/sohutv/cachecloud">https://github.com/sohutv/cachecloud</a></div><div><br/></div></div></span>
</div></body></html> 